 

[TOC]

## 一、java基础知识

### 1.1 接口和抽象类的区别

抽象类：含有抽象方法的类，就是抽象类。（抽象方法不是必须）

接口： 是一系列方法的声明，是一些方法特征的集合 

共同点：

1、自己都不能实例化自己，需要通过子类来实例化；

区别

1、一个类只能继承一个抽象类，但可以实现多个接口；

2、抽象类可以提供某些方法的部分实现，接口不行；

3、抽象类可以有非抽象方法，接口中的所有方法都是抽象方法。

4、抽象类的实现可以是任何类型，接口属性默认修饰符是public static final；



### 1.2 java面向对象编程三大特性

三大特性：封装、继承、多态

***封装：***封装是把一个对象的属性私有化，同时提供一些可以被外界访问属性的方法。

***继承：***子类通过继承父类，可以使用父类中的一些方法和变量，提高代码的复用性。
继承的主要特性：
    1、不支持多继承，子类至多只能继承一个父类，但是可以通过实现多个接口来实现多重继承的目的；
    2、子类拥有父类中的所有属性和方法，但是无法访问私有属性和方法，只能访问父类的非私有(public和protected)变量和方法；
    3、子类的方法和父类的方法重名，方法参数一致时，会覆盖父类方法。也就是重写。

***多态***：同一个操作用在不同对象，有不同的语义，产生不同的结果

多态的主要有两种表现方式：
    1、重载：方法名相同，参数不相同(编译时多态)
    2、重写：方法名相同，参数相同(运行时多态)
区别：
    1、覆盖是一对一，重载可以是多个方法之间的关系；
    2、覆盖要求参数名、类型、顺序相同，重载要求不同；
    3、覆盖是编译时多态，重载是运行时多态；

### 1.3 spring

#### 1.3.1 动态代理

概念：在程序运行时，根据程序需要，动态创建代理类及其实例来完成具体的功能。

常用的动态代理：

（1）jdk动态代理：

1、要实现InvocationHandler接口；

2、通过反射来调用方法；

3、只能实现对接口的动态代理，不能实现对类的动态代理；(因为它的代理对象已经继承了Proxy对象，需要实现代理接口中的方法)

4、代理对象是对目标的增强，以便对消息进行预处理和后处理；

（2）cglib动态代理

1、实现MethordIntercepter

2、代理对象继承被代理对象，实现了Factory接口

#### 1.3.2 AOP

**概念：**

> （ Aspect Oriented Programming ），意为面向切面编程。通过预编译的方式和程序运行时动态代理实现程序功能的统一维护的一种技术。

**特征：**

> 1、面向切面编程具有良好的隔离性
>
> 2、具有代码无关性

**spring AOP加载的步骤**

1、spring容器启动时，加载相关的配置文件

2、创建bean相关对象

3、解析aop:config的配置，解析切点表达式，如果匹配成功，则会为该bean创建代理对象，代理对象的方法=目标方法+通知；不匹配则不会创建。

4、在客户端利用context.getBean()获取对象时，如果有代理对象则返回代理对象，没有就返回对象本身；（如果是对类的代理，则使用cglib代理，如果是对接口的代理，则使用的jdk动态代理）

#### 1.3.3 IOC

**概念**

> 控制反转是面向对象编程中的一种设计原则，可以减少代码之间的耦合度。通常的方式叫依赖注入，还有一种方式叫依赖查询。IOC利用java的反射机制，AOP利用代理模式。
>

简单理解：将对象交给容器统一进行管理，spring容器启动时加载配置文件或者扫描注解创建bean，使用时，spring容器分配给我们。

#### 1.3.4 SSM框架

1、是什么？

Spring+SpringMVC+mybatis

2、各层之间的关系



### 1.4 String、StringBuffer 和 StringBuilder 的区别是什么？String 为什么是不可变的?

***相同点：***

String、StringBuffer和StringBuilder内部都是通过 char数组 实现的。

***不同点：***

**1、可变性**

String内部char数组是final类型的，不可变，修改String实际上是new了一个新的String对象返回；

StringBuffer和StringBuilder都继承了 AbstractStringBuilder，当发现长度不够16时，会自动扩容，扩展为原数组长度的2倍+2，创建一个新的数组，将数据复制到新数组。

**2、线程安全**

String内部是定长数组，所以是安全的。

StringBuilder中的方法没有加 `synchronized` 锁，线程不安全

StringBuffer中的方法几乎都加了`synchronized` 锁，线程安全

**3、性能**

StringBuilder和StringBuffer修改，其实是修改数组内部的数据，String修改内容，是new了一个新对象，把指针指向新对象，所以

StringBuilder和StringBuffer的开销小一些，性能要好一些。

### 1.5 自动装箱与拆箱

自动装箱：将基本数据类型转换为包装器类型。

自动拆箱：将包装类型转为基本数据类型

### 1.6 静态方法

#### 1.6.1 在一个静态方法内调用一个非静态成员为什么是非法的?

静态方法是随着类加载时而加载的，通过类名加方法名直接调用，非静态成员变量属于类的对象，只有在类的实例创建时，才会创建，通过实例去调用。类的非静态成员不存在时，静态成员和方法以及存在，访问内存不存在非静态成员，没意义，所以是非法的。

#### 1.6.2 静态方法和实例方法有何不同

1、静态方法是在类加载器加载时，创建存在，存在于，可以通过“对象名.方法名”调用。实例方法，是类在创建时，创建的，通过“实例名。方法名”调用。

2、静态变量只能访问类中的静态变量和方法，非静态方法不受限制。



### 1.7 构造方法

#### 1.7.1 构造方法有哪些特性？

1、与类名相同

2、没有返回值。

3、 构造方法可以没有（默认一个无参构造方法） ， 也可以有多个构造方法 。

4、 如果定义有参构造函数，没有定义无参构造函数，则无参构造函数将被自动屏蔽 。

5、构造方法不能手动调用，会自动执行。



#### 1.7.2 在 Java 中定义一个不做事且没有参数的构造方法的作用

class创建实例时，会调用构造函数创建，如果没有构造函数，会调用默认的没有参数的构造函数。

#### 1.7.3 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?

构造方法，完成类对象的初始化工作。可以正确执行，因为类在没有构造方法时，会有一个不带参数的默认构造方法。





### 1.8 import java和javax有什么区别？

 刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax  逐渐地扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java  包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准API的一部分 

### 1.9 成员变量与局部变量的区别有哪些？

1、作用域不同

成员变量属于类的，局部变量只在方法内有效。

2、生命周期不同

成员变量生命周期随着类的存在和消失，局部变量，在方法调用时存在，调用完就回收了。

3、初始值

成员变量有默认的初始值，局部变量没有默认的初始值，需要初始化

### 1.10 对象

#### 1.10.1 创建一个对象用什么运算符?对象实体与对象引用有何不同?

创建对象使用new操作符，对象实体存在于堆中，对象引用存在于栈中。一个对象引用可以指向0个或者1个对象实体，一个对象实体可以被多个对象引用指向。

#### 1.10.2 对象的相等与指向他们的引用相等,两者有什么不同?

对象相等，是比较对象在内存中的内容是否相等；引用相等，是比较指向他们的引用

### 1.11 什么是方法的返回值?返回值在类的方法里的作用是什么?

简单的说，就是返回方法执行的结果。

### 1.12 == 与 equals(重要)

==是判断2个对象的地址是否相同，equals如果没覆盖equals()方法，和==一样，如果覆盖了equals()方法，则按照覆盖的规则执行。

### 1.13 hashCode 与 equals (重要)

两个对象equals相等，则它们的hashCode 相等；

两个对象的hashCode相等，它们不一定相等。

### 1.14 多线程

#### 1.14.1简述线程、程序、进程的基本概念。以及他们之间关系是什么?

***线程：*** 是操作系统进行运算调度的最小单位；

***进程：*** 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。简述，程序的一次执行过程。

 ***程序：***是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码 



关系：

一个程序可以包含多个进程，一个进程可以包含多个线程。

## 三、数据库

### 3.1 数据库三范式

#### 3.1.1 第一范式(1NF)

所有的域都应该是原子性，数据库每一列都是不可分割的基本数据项；

#### 3.1.2 第二范式(2NF)

满足第一范式的前提下，表中的所有非主键字段必须依赖主键，不能只依赖一部分。（主要为了减少冗余）

#### 3.1.3 第三范式(3NF)

满足第二范式的前提下，表中的非主键字段不能依赖其它表的非主键字段

### 3.2 数据库五大约束

1、主键约束( primary KEY )

2、唯一性约束（ UNIQUE ）

3、外键约束（ FOREIGN key ）

4、默认值约束（ DEFAULT ）

5、非空约束（ NOT NULL ）

### 3.3、内外连接和交叉连接

#### 3.3.1 内连接

两个表内连接，返回子集

#### 3.3.2 外连接

外连接分为：左连接（left join）、右连接(right join)、全连接(full join)

左连接：返回左表的所有数据，右表没有匹配行，则右表属性返回NULL

右连接：返回右表所有数据，左表没有匹配行，则左表属性返回NULL

全连接：返回左右表的所有行，当某个表的一行在另一个表中没有匹配，则另一个表的字段属性返回NULL

#### 3.3.3 交叉连接

返回左表中的所有行与右表中的所有行形成的组合，也成笛卡尔积。

### 3.4 事务

#### 3.4.1 事务的4大特性(ACID)

**原子性( Atomicity )**：一个事务必须是不可再分割的单位。要么都发生，要么都不发生；

**一致性(Consistency)**:一个事务执行前后数据必须保持一致；

**隔离性(Isolation):**并发的事务是相互隔离的，互不干扰；既同一时间，只允许一个事务操作数据。

**持久性(Durability):**在事务完成后，该事务对数据库的更改长久的保存在数据库之中，并不会回滚。

